const { expect } = require('chai');
const { it } = require('mocha');
//import MagicalObject from "./../lib/MagicalObject"
const BaseObject = require('../lib/BaseObject').default;
///*
const SeperatorMethods = '::';
describe('define className baseobject', function () {
    class TestBaseObject extends BaseObject {}
    //const test = new TestBaseObject();
    expect(TestBaseObject.className()).equal('TestBaseObject');
});
describe('define getter baseobject', function () {
    describe('error getter Unknown Property', function () {
        class TestBaseObject extends BaseObject {
            test = 'test';
        }
        const test = new TestBaseObject();
        try {
            test.test;
        } catch (error) {
            //console.log(error.getMessage());
            expect(error.getName()).equal('Unknown Property');
            expect(error.getMessage()).equal('Getting unknown property: TestBaseObject' + SeperatorMethods + 'test');
        }
    });
    describe('error getter InvalidCallException:', function () {
        class TestBaseObject extends BaseObject {
            test = 'test';
            setTest(value) {
                this.test = value;
            }
        }
        const test = new TestBaseObject();
        try {
            test.test;
        } catch (error) {
            expect(error.getName()).equal('InvalidCallException');
            expect(error.getMessage()).equal('Getting write-only property: TestBaseObject' + SeperatorMethods + 'test');
        }
    });
    describe('success define getter:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
            getTest() {
                return this._tes;
            }
        }
        const obj = new TestBaseObject();
        expect(obj.test).equal('test');
    });
});

describe('define setter baseobject', function () {
    describe('error setter Unknown Property', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
        }
        const obj = new TestBaseObject();
        try {
            obj.test = 'aaaa';
        } catch (error) {
            //console.log(error.getMessage());
            expect(error.getName()).equal('Unknown Property');
            expect(error.getMessage()).equal('Setting unknown property: TestBaseObject' + SeperatorMethods + 'test');
        }
    });
    describe('error getter InvalidCallException:', function () {
        class TestBaseObject extends BaseObject {
            test = 'test';
            getTest(value) {
                this.test = value;
            }
        }
        const test = new TestBaseObject();
        try {
            test.test = 'aaaa';
        } catch (error) {
            expect(error.getName()).equal('InvalidCallException');
            expect(error.getMessage()).equal('Setting read-only property: TestBaseObject' + SeperatorMethods + 'test');
        }
    });
    describe('success define getter:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
            setTest(value) {
                this._tes = value;
            }
            getTest() {
                return this._tes;
            }
        }
        const obj = new TestBaseObject();
        obj.test = 'aaaa';
        expect(obj.test).equal('aaaa');
    });
});
describe('define isset baseobject', function () {
    describe('should return false', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
        }
        const obj = new TestBaseObject();
        expect(obj.hasOwnProperty('test')).equal(false);
    });
    describe('should return true:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
            getTest() {
                return this._tes;
            }
        }
        const obj = new TestBaseObject();
        expect(obj.hasOwnProperty('test')).equal(true);
    });
});
describe('define unset baseobject', function () {
    describe('should return error:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
            getTest() {
                return this._tes;
            }
        }
        const obj = new TestBaseObject();

        try {
            delete obj.test;
        } catch (error) {
            expect(error.getName()).equal('InvalidCallException');
            expect(error.getMessage()).equal(
                'Unsetting read-only property: TestBaseObject' + SeperatorMethods + 'test',
            );
        }
    });
    describe('should return false:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
        }
        const obj = new TestBaseObject();

        const flag = delete obj.test;
        expect(flag).equal(false);
    });

    describe('success delete property:', function () {
        class TestBaseObject extends BaseObject {
            _tes = 'test';
            setTest(value) {
                return (this._tes = value);
            }
            getTest() {
                return this._tes;
            }
        }
        const obj = new TestBaseObject();
        delete obj.test;
        expect(obj.test).equal(null);
    });
});
describe('define call baseobject', function () {
    describe('should error when call function', function () {
        class TestBaseObject extends BaseObject {
            //someDo() {
            //    return false;
            //}
        }
        const obj = new TestBaseObject();
        //try {
        obj.someDo();
        //} catch (error) {
        //    expect(error.getName()).equal('Unknown Method');
        //    expect(error.getMessage()).equal('Calling unknown method: TestBaseObject' + SeperatorMethods + 'someDo()');
        //}
    });
});
describe('define General baseobject', function () {
    class TestBaseObject extends BaseObject {
        someDo() {
            return false;
        }
    }
    const obj = new TestBaseObject();
    describe('should true  when check method exist', function () {
        expect(obj.hasMethod('someDo')).equal(true);
    });
});
